<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Учим слоги</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const Shuffle = () => (
            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M16 3h5v5M4 20L21 3M21 16v5h-5M15 15l6 6M4 4l5 5"/>
            </svg>
        );

        const Filter = () => (
            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>
            </svg>
        );

        // 3D Game Component
        const Game3D = ({ onBack, consonants, vowels, isValidSyllable, syllableOrder, isUpperCase }) => {
          const { useState, useEffect, useRef } = React;
          const mountRef = useRef(null);
          const sceneRef = useRef(null);
          const cameraRef = useRef(null);
          const rendererRef = useRef(null);
          const carRef = useRef(null);
          const roadSegmentsRef = useRef([]);
          const obstaclesRef = useRef([]);
          const animationFrameRef = useRef(null);
          const sceneryObjectsRef = useRef([]);

          const [gameState, setGameState] = useState('playing'); // 'playing' or 'gameover'
          const [speed, setSpeed] = useState(100);
          const [score, setScore] = useState(0);
          const [correctAnswers, setCorrectAnswers] = useState(0);
          const [totalQuestions, setTotalQuestions] = useState(0);
          const [currentQuestion, setCurrentQuestion] = useState(null);
          const [hasAnswered, setHasAnswered] = useState(false);
          const [selectedSide, setSelectedSide] = useState(null);
          const [showInstructions, setShowInstructions] = useState(true);
          const currentObstacleRef = useRef(null);

          // Generate a random syllable
          const generateSyllable = () => {
            let consonant, vowel;
            do {
              consonant = consonants[Math.floor(Math.random() * consonants.length)];
              vowel = vowels[Math.floor(Math.random() * vowels.length)];
            } while (syllableOrder === 'cv' && !isValidSyllable(consonant, vowel));
            return syllableOrder === 'cv' ? consonant + vowel : vowel + consonant;
          };

          // Generate wrong syllable (different from correct one)
          const generateWrongSyllable = (correctSyllable) => {
            let wrongSyllable;
            do {
              wrongSyllable = generateSyllable();
            } while (wrongSyllable === correctSyllable);
            return wrongSyllable;
          };

          // Create new question
          const createNewQuestion = () => {
            const correctSyllable = generateSyllable();
            const wrongSyllable = generateWrongSyllable(correctSyllable);
            const isCorrectOnLeft = Math.random() > 0.5;

            return {
              correctSyllable,
              wrongSyllable,
              leftSyllable: isCorrectOnLeft ? correctSyllable : wrongSyllable,
              rightSyllable: isCorrectOnLeft ? wrongSyllable : correctSyllable,
              correctSide: isCorrectOnLeft ? 'left' : 'right'
            };
          };

          // Speak syllable
          const speakSyllable = (syllable) => {
            if ('speechSynthesis' in window) {
              const utterance = new SpeechSynthesisUtterance(syllable);
              utterance.lang = 'ru-RU';
              utterance.rate = 0.7;
              utterance.pitch = 1.2;
              window.speechSynthesis.cancel();
              window.speechSynthesis.speak(utterance);
            }
          };

          // Initialize Three.js scene
          useEffect(() => {
            if (!mountRef.current) return;

            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 10, 100);
            sceneRef.current = scene;

            // Camera setup
            const camera = new THREE.PerspectiveCamera(
              75,
              window.innerWidth / window.innerHeight,
              0.1,
              1000
            );
            camera.position.set(0, 3, 5);
            camera.lookAt(0, 0, -10);
            cameraRef.current = camera;

            // Renderer setup
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            mountRef.current.appendChild(renderer.domElement);
            rendererRef.current = renderer;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xFFF8DC, 1.0);
            directionalLight.position.set(10, 15, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Add a warm fill light
            const fillLight = new THREE.DirectionalLight(0xFFE4B5, 0.3);
            fillLight.position.set(-5, 5, -5);
            scene.add(fillLight);

            // Add sun/moon sphere in the sky
            const sunGeometry = new THREE.SphereGeometry(3, 16, 16);
            const sunMaterial = new THREE.MeshBasicMaterial({
              color: 0xFFDD88,
              emissive: 0xFFDD88,
              emissiveIntensity: 1
            });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(30, 25, -40);
            scene.add(sun);

            // Create road segments with significant overlap
            const roadGeometry = new THREE.PlaneGeometry(8, 25);
            const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

            for (let i = 0; i < 8; i++) {
              const roadSegment = new THREE.Mesh(roadGeometry, roadMaterial);
              roadSegment.rotation.x = -Math.PI / 2;
              roadSegment.position.z = -i * 24; // 25 unit segments with 1 unit overlap
              roadSegment.receiveShadow = true;
              roadSegment.userData.isRoad = true;
              scene.add(roadSegment);
              roadSegmentsRef.current.push(roadSegment);
            }

            // Add road markings separately (dashed line in center)
            const markingGeometry = new THREE.PlaneGeometry(0.3, 2);
            const markingMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });

            for (let i = 0; i < 60; i++) {
              const marking = new THREE.Mesh(markingGeometry, markingMaterial);
              marking.rotation.x = -Math.PI / 2;
              marking.position.set(0, 0.01, -i * 3);
              scene.add(marking);
              roadSegmentsRef.current.push(marking);
            }

            // Create grass on sides (repeating segments)
            const grassGeometry = new THREE.PlaneGeometry(50, 100);
            const grassMaterial = new THREE.MeshStandardMaterial({ color: 0x2d5016 });

            // Create multiple grass segments for seamless looping
            for (let i = 0; i < 4; i++) {
              const grassLeft = new THREE.Mesh(grassGeometry, grassMaterial);
              grassLeft.rotation.x = -Math.PI / 2;
              grassLeft.position.x = -29;
              grassLeft.position.z = -i * 100;
              grassLeft.receiveShadow = true;
              scene.add(grassLeft);
              roadSegmentsRef.current.push(grassLeft);

              const grassRight = new THREE.Mesh(grassGeometry, grassMaterial);
              grassRight.rotation.x = -Math.PI / 2;
              grassRight.position.x = 29;
              grassRight.position.z = -i * 100;
              grassRight.receiveShadow = true;
              scene.add(grassRight);
              roadSegmentsRef.current.push(grassRight);
            }

            // Add trees along the road
            const createTree = (x, z) => {
              const treeGroup = new THREE.Group();

              // Tree trunk
              const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 6);
              const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
              const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
              trunk.position.y = 1;
              trunk.castShadow = true;
              treeGroup.add(trunk);

              // Tree foliage (3 spheres)
              const foliageGeometry = new THREE.SphereGeometry(1.2, 6, 6);
              const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });

              const foliage1 = new THREE.Mesh(foliageGeometry, foliageMaterial);
              foliage1.position.y = 2.5;
              foliage1.castShadow = true;
              treeGroup.add(foliage1);

              const foliage2 = new THREE.Mesh(foliageGeometry, foliageMaterial);
              foliage2.position.y = 3.5;
              foliage2.scale.set(0.8, 0.8, 0.8);
              foliage2.castShadow = true;
              treeGroup.add(foliage2);

              const foliage3 = new THREE.Mesh(foliageGeometry, foliageMaterial);
              foliage3.position.y = 4.3;
              foliage3.scale.set(0.5, 0.5, 0.5);
              foliage3.castShadow = true;
              treeGroup.add(foliage3);

              treeGroup.position.set(x, 0, z);
              return treeGroup;
            };

            // Place trees along the road
            for (let i = 0; i < 20; i++) {
              const z = -i * 8;

              // Trees on left side
              const treeLeft = createTree(-8 - Math.random() * 3, z + Math.random() * 4);
              scene.add(treeLeft);
              sceneryObjectsRef.current.push({ obj: treeLeft, resetZ: -160 });

              // Trees on right side
              const treeRight = createTree(8 + Math.random() * 3, z + Math.random() * 4);
              scene.add(treeRight);
              sceneryObjectsRef.current.push({ obj: treeRight, resetZ: -160 });
            }

            // Add clouds in the sky
            const createCloud = (x, y, z) => {
              const cloudGroup = new THREE.Group();
              const cloudMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.8
              });

              // Cloud made of spheres
              for (let i = 0; i < 5; i++) {
                const size = 1 + Math.random() * 1.5;
                const sphere = new THREE.Mesh(
                  new THREE.SphereGeometry(size, 6, 6),
                  cloudMaterial
                );
                sphere.position.x = (Math.random() - 0.5) * 4;
                sphere.position.y = (Math.random() - 0.5) * 1;
                sphere.position.z = (Math.random() - 0.5) * 2;
                cloudGroup.add(sphere);
              }

              cloudGroup.position.set(x, y, z);
              return cloudGroup;
            };

            // Add clouds
            for (let i = 0; i < 10; i++) {
              const cloud = createCloud(
                (Math.random() - 0.5) * 80,
                15 + Math.random() * 10,
                -Math.random() * 100
              );
              scene.add(cloud);
            }

            // Add mountains in the far background
            const createMountain = (x, z) => {
              const mountainGeometry = new THREE.ConeGeometry(
                3 + Math.random() * 4,
                8 + Math.random() * 8,
                4
              );
              const mountainMaterial = new THREE.MeshStandardMaterial({
                color: 0x666666,
                flatShading: true
              });
              const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
              mountain.position.set(x, 0, z);
              mountain.castShadow = false;
              mountain.receiveShadow = false;

              // Add snow cap
              const snowGeometry = new THREE.ConeGeometry(
                (3 + Math.random() * 4) * 0.6,
                (8 + Math.random() * 8) * 0.4,
                4
              );
              const snowMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                flatShading: true
              });
              const snow = new THREE.Mesh(snowGeometry, snowMaterial);
              snow.position.y = mountain.geometry.parameters.height * 0.6;
              mountain.add(snow);

              return mountain;
            };

            // Add mountains far in the background
            for (let i = 0; i < 12; i++) {
              const mountain = createMountain(
                (Math.random() - 0.5) * 100,
                -60 - Math.random() * 40
              );
              scene.add(mountain);
            }

            // Add simple buildings in the distance
            const createBuilding = (x, z) => {
              const height = 5 + Math.random() * 10;
              const width = 2 + Math.random() * 2;
              const depth = 2 + Math.random() * 2;

              const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
              const buildingMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(Math.random(), 0.3, 0.5)
              });
              const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
              building.position.set(x, height / 2, z);
              building.castShadow = true;
              building.receiveShadow = true;

              return building;
            };

            // Add buildings on both sides (far from road)
            for (let i = 0; i < 15; i++) {
              const z = -Math.random() * 100;

              // Buildings on left side
              const buildingLeft = createBuilding(-15 - Math.random() * 10, z);
              scene.add(buildingLeft);
              sceneryObjectsRef.current.push({ obj: buildingLeft, resetZ: -100 });

              // Buildings on right side
              const buildingRight = createBuilding(15 + Math.random() * 10, z);
              scene.add(buildingRight);
              sceneryObjectsRef.current.push({ obj: buildingRight, resetZ: -100 });
            }

            // Add street lamps along the road
            const createStreetLamp = (x, z) => {
              const lampGroup = new THREE.Group();

              // Pole
              const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 4, 6);
              const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
              const pole = new THREE.Mesh(poleGeometry, poleMaterial);
              pole.position.y = 2;
              pole.castShadow = true;
              lampGroup.add(pole);

              // Lamp head
              const lampHeadGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.4);
              const lampHeadMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFF88,
                emissive: 0xFFFF00,
                emissiveIntensity: 0.5
              });
              const lampHead = new THREE.Mesh(lampHeadGeometry, lampHeadMaterial);
              lampHead.position.y = 4.2;
              lampGroup.add(lampHead);

              lampGroup.position.set(x, 0, z);
              return lampGroup;
            };

            // Add street lamps
            for (let i = 0; i < 25; i++) {
              const z = -i * 6;

              // Lamps on left side of road
              const lampLeft = createStreetLamp(-5, z);
              scene.add(lampLeft);
              sceneryObjectsRef.current.push({ obj: lampLeft, resetZ: -150 });

              // Lamps on right side of road
              const lampRight = createStreetLamp(5, z);
              scene.add(lampRight);
              sceneryObjectsRef.current.push({ obj: lampRight, resetZ: -150 });
            }

            // Add rocks/bushes as decoration
            const createRock = (x, z) => {
              const rockGeometry = new THREE.DodecahedronGeometry(0.3 + Math.random() * 0.4, 0);
              const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
              const rock = new THREE.Mesh(rockGeometry, rockMaterial);
              rock.position.set(x, 0.2, z);
              rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
              rock.castShadow = true;
              return rock;
            };

            // Add random rocks
            for (let i = 0; i < 30; i++) {
              const z = -Math.random() * 100;
              const side = Math.random() > 0.5 ? 1 : -1;
              const x = side * (6 + Math.random() * 4);
              const rock = createRock(x, z);
              scene.add(rock);
              sceneryObjectsRef.current.push({ obj: rock, resetZ: -100 });
            }

            // Add some flowers/bushes on the grass
            const createFlower = (x, z) => {
              const flowerGroup = new THREE.Group();

              // Stem
              const stemGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 4);
              const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
              const stem = new THREE.Mesh(stemGeometry, stemMaterial);
              stem.position.y = 0.15;
              flowerGroup.add(stem);

              // Flower head
              const petalColors = [0xFF69B4, 0xFFFF00, 0xFF6347, 0xFF00FF, 0x00BFFF];
              const color = petalColors[Math.floor(Math.random() * petalColors.length)];
              const headGeometry = new THREE.SphereGeometry(0.1, 6, 6);
              const headMaterial = new THREE.MeshStandardMaterial({ color: color });
              const head = new THREE.Mesh(headGeometry, headMaterial);
              head.position.y = 0.35;
              flowerGroup.add(head);

              flowerGroup.position.set(x, 0, z);
              return flowerGroup;
            };

            // Add flowers
            for (let i = 0; i < 40; i++) {
              const z = -Math.random() * 100;
              const side = Math.random() > 0.5 ? 1 : -1;
              const x = side * (7 + Math.random() * 3);
              const flower = createFlower(x, z);
              scene.add(flower);
              sceneryObjectsRef.current.push({ obj: flower, resetZ: -100 });
            }

            // Add animated birds
            const createBird = (x, y, z) => {
              const birdGroup = new THREE.Group();

              // Simple bird shape made of triangles
              const wingMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });

              // Left wing
              const leftWingGeometry = new THREE.BufferGeometry();
              const leftWingVertices = new Float32Array([
                0, 0, 0,
                -0.3, 0, 0.2,
                0, 0, 0.1
              ]);
              leftWingGeometry.setAttribute('position', new THREE.BufferAttribute(leftWingVertices, 3));
              const leftWing = new THREE.Mesh(leftWingGeometry, wingMaterial);
              birdGroup.add(leftWing);

              // Right wing
              const rightWingGeometry = new THREE.BufferGeometry();
              const rightWingVertices = new Float32Array([
                0, 0, 0,
                0.3, 0, 0.2,
                0, 0, 0.1
              ]);
              rightWingGeometry.setAttribute('position', new THREE.BufferAttribute(rightWingVertices, 3));
              const rightWing = new THREE.Mesh(rightWingGeometry, wingMaterial);
              birdGroup.add(rightWing);

              birdGroup.position.set(x, y, z);
              birdGroup.userData.wingAngle = 0;
              birdGroup.userData.leftWing = leftWing;
              birdGroup.userData.rightWing = rightWing;
              birdGroup.userData.speed = 0.02 + Math.random() * 0.02;
              birdGroup.userData.orbitRadius = 10 + Math.random() * 20;
              birdGroup.userData.orbitAngle = Math.random() * Math.PI * 2;
              birdGroup.userData.orbitCenterX = x;
              birdGroup.userData.orbitCenterZ = z;

              return birdGroup;
            };

            // Add several birds
            const birds = [];
            for (let i = 0; i < 8; i++) {
              const bird = createBird(
                (Math.random() - 0.5) * 40,
                8 + Math.random() * 8,
                -20 - Math.random() * 60
              );
              scene.add(bird);
              birds.push(bird);

              // Store initial Z for movement with scenery
              bird.userData.initialZ = bird.position.z;
            }

            // Create player car (enhanced low-poly sports car style)
            const carGroup = new THREE.Group();

            // Car body (main chassis) - wider and sleeker
            const bodyGeometry = new THREE.BoxGeometry(1.6, 0.6, 2.8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
              color: 0xFF0000,
              metalness: 0.6,
              roughness: 0.4
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            carGroup.add(body);

            // Lower body/chassis
            const lowerBodyGeometry = new THREE.BoxGeometry(1.7, 0.3, 2.6);
            const lowerBody = new THREE.Mesh(lowerBodyGeometry, bodyMaterial);
            lowerBody.position.y = 0.2;
            lowerBody.castShadow = true;
            carGroup.add(lowerBody);

            // Car cabin (more aerodynamic)
            const cabinGeometry = new THREE.BoxGeometry(1.4, 0.7, 1.6);
            const cabinMaterial = new THREE.MeshStandardMaterial({
              color: 0xCC0000,
              metalness: 0.5,
              roughness: 0.5
            });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabin.position.y = 1.05;
            cabin.position.z = -0.3;
            cabin.castShadow = true;
            carGroup.add(cabin);

            // Roof
            const roofGeometry = new THREE.BoxGeometry(1.3, 0.2, 1.2);
            const roof = new THREE.Mesh(roofGeometry, cabinMaterial);
            roof.position.y = 1.5;
            roof.position.z = -0.3;
            roof.castShadow = true;
            carGroup.add(roof);

            // Windows
            const windowMaterial = new THREE.MeshStandardMaterial({
              color: 0x333333,
              transparent: true,
              opacity: 0.3,
              metalness: 0.9,
              roughness: 0.1
            });

            // Front windshield
            const frontWindowGeometry = new THREE.PlaneGeometry(1.3, 0.6);
            const frontWindow = new THREE.Mesh(frontWindowGeometry, windowMaterial);
            frontWindow.position.set(0, 1.1, 0.5);
            frontWindow.rotation.x = -0.2;
            carGroup.add(frontWindow);

            // Rear window
            const rearWindow = new THREE.Mesh(frontWindowGeometry, windowMaterial);
            rearWindow.position.set(0, 1.1, -1.1);
            rearWindow.rotation.x = 0.2;
            rearWindow.rotation.y = Math.PI;
            carGroup.add(rearWindow);

            // Side windows
            const sideWindowGeometry = new THREE.PlaneGeometry(1.4, 0.5);
            const leftWindow = new THREE.Mesh(sideWindowGeometry, windowMaterial);
            leftWindow.position.set(-0.7, 1.1, -0.3);
            leftWindow.rotation.y = Math.PI / 2;
            carGroup.add(leftWindow);

            const rightWindow = new THREE.Mesh(sideWindowGeometry, windowMaterial);
            rightWindow.position.set(0.7, 1.1, -0.3);
            rightWindow.rotation.y = -Math.PI / 2;
            carGroup.add(rightWindow);

            // Front bumper
            const bumperGeometry = new THREE.BoxGeometry(1.7, 0.2, 0.3);
            const bumperMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const frontBumper = new THREE.Mesh(bumperGeometry, bumperMaterial);
            frontBumper.position.set(0, 0.25, 1.55);
            frontBumper.castShadow = true;
            carGroup.add(frontBumper);

            // Rear bumper
            const rearBumper = new THREE.Mesh(bumperGeometry, bumperMaterial);
            rearBumper.position.set(0, 0.25, -1.55);
            rearBumper.castShadow = true;
            carGroup.add(rearBumper);

            // Headlights
            const headlightGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const headlightMaterial = new THREE.MeshStandardMaterial({
              color: 0xFFFFFF,
              emissive: 0xFFFFFF,
              emissiveIntensity: 0.8
            });

            const leftHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            leftHeadlight.position.set(-0.5, 0.4, 1.45);
            carGroup.add(leftHeadlight);

            const rightHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            rightHeadlight.position.set(0.5, 0.4, 1.45);
            carGroup.add(rightHeadlight);

            // Taillights
            const taillightMaterial = new THREE.MeshStandardMaterial({
              color: 0xFF0000,
              emissive: 0xFF0000,
              emissiveIntensity: 0.5
            });

            const leftTaillight = new THREE.Mesh(headlightGeometry, taillightMaterial);
            leftTaillight.position.set(-0.5, 0.5, -1.45);
            carGroup.add(leftTaillight);

            const rightTaillight = new THREE.Mesh(headlightGeometry, taillightMaterial);
            rightTaillight.position.set(0.5, 0.5, -1.45);
            carGroup.add(rightTaillight);

            // Side mirrors
            const mirrorGeometry = new THREE.BoxGeometry(0.1, 0.15, 0.25);
            const mirrorMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

            const leftMirror = new THREE.Mesh(mirrorGeometry, mirrorMaterial);
            leftMirror.position.set(-0.85, 1.0, 0.3);
            carGroup.add(leftMirror);

            const rightMirror = new THREE.Mesh(mirrorGeometry, mirrorMaterial);
            rightMirror.position.set(0.85, 1.0, 0.3);
            carGroup.add(rightMirror);

            // Spoiler
            const spoilerBaseGeometry = new THREE.BoxGeometry(0.2, 0.5, 0.1);
            const spoilerBase = new THREE.Mesh(spoilerBaseGeometry, bodyMaterial);
            spoilerBase.position.set(0, 1.1, -1.4);
            carGroup.add(spoilerBase);

            const spoilerWingGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.4);
            const spoilerWing = new THREE.Mesh(spoilerWingGeometry, bodyMaterial);
            spoilerWing.position.set(0, 1.4, -1.4);
            spoilerWing.castShadow = true;
            carGroup.add(spoilerWing);

            // Wheels with better design (tire + rim)
            const wheelPositions = [
              [-0.8, 0.3, 0.9],
              [0.8, 0.3, 0.9],
              [-0.8, 0.3, -0.9],
              [0.8, 0.3, -0.9]
            ];

            wheelPositions.forEach(pos => {
              const wheelGroup = new THREE.Group();

              // Tire
              const tireGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.35, 12);
              const tireMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
              const tire = new THREE.Mesh(tireGeometry, tireMaterial);
              tire.castShadow = true;
              wheelGroup.add(tire);

              // Rim (inner part)
              const rimGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.37, 12);
              const rimMaterial = new THREE.MeshStandardMaterial({
                color: 0xC0C0C0,
                metalness: 0.8,
                roughness: 0.2
              });
              const rim = new THREE.Mesh(rimGeometry, rimMaterial);
              wheelGroup.add(rim);

              // Rim center cap
              const capGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.38, 8);
              const capMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                metalness: 0.6,
                roughness: 0.3
              });
              const cap = new THREE.Mesh(capGeometry, capMaterial);
              wheelGroup.add(cap);

              wheelGroup.rotation.z = Math.PI / 2;
              wheelGroup.position.set(...pos);
              carGroup.add(wheelGroup);
            });

            // Hood details (air vents)
            const ventGeometry = new THREE.BoxGeometry(0.3, 0.05, 0.15);
            const ventMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });

            const leftVent = new THREE.Mesh(ventGeometry, ventMaterial);
            leftVent.position.set(-0.3, 0.85, 0.8);
            carGroup.add(leftVent);

            const rightVent = new THREE.Mesh(ventGeometry, ventMaterial);
            rightVent.position.set(0.3, 0.85, 0.8);
            carGroup.add(rightVent);

            carGroup.position.set(0, 0, 2);
            scene.add(carGroup);
            carRef.current = carGroup;

            // Start with first question
            const firstQuestion = createNewQuestion();
            setCurrentQuestion(firstQuestion);
            speakSyllable(firstQuestion.correctSyllable);

            // Animation loop
            let roadOffset = 0;
            const animate = () => {
              animationFrameRef.current = requestAnimationFrame(animate);

              // Animate birds (always, even when game is paused)
              birds.forEach(bird => {
                // Wing flapping
                bird.userData.wingAngle += 0.15;
                const flapAngle = Math.sin(bird.userData.wingAngle) * 0.5;

                bird.userData.leftWing.rotation.y = flapAngle;
                bird.userData.rightWing.rotation.y = -flapAngle;

                // Circular flight path (relative to orbit center)
                bird.userData.orbitAngle += bird.userData.speed;
                const relativeX = Math.cos(bird.userData.orbitAngle) * bird.userData.orbitRadius;
                const relativeZ = Math.sin(bird.userData.orbitAngle) * bird.userData.orbitRadius;

                bird.position.x = bird.userData.orbitCenterX + relativeX;

                // Update Z based on orbit center which moves with scenery
                bird.position.z = bird.userData.orbitCenterZ + relativeZ;

                // Face the direction of movement
                bird.rotation.y = bird.userData.orbitAngle + Math.PI / 2;
              });

              if (gameState === 'playing' && speed > 0) {
                // Move road
                const moveSpeed = speed / 1000;
                roadOffset += moveSpeed;

                roadSegmentsRef.current.forEach(segment => {
                  segment.position.z += moveSpeed;
                  // Road markings and road segments loop at 192
                  if (segment.userData.isRoad || !segment.geometry.parameters) {
                    if (segment.position.z > 20) {
                      segment.position.z -= 192; // 8 segments * 24 spacing
                    }
                  }
                  // Grass segments loop at 400 (4 segments * 100)
                  else if (segment.position.z > 20) {
                    segment.position.z -= 400;
                  }
                });

                // Move all scenery objects
                sceneryObjectsRef.current.forEach(item => {
                  item.obj.position.z += moveSpeed;
                  // When object passes behind camera, reset it far ahead
                  if (item.obj.position.z > 20) {
                    item.obj.position.z = item.resetZ;
                  }
                });

                // Move bird orbit centers with the road
                birds.forEach(bird => {
                  bird.userData.orbitCenterZ += moveSpeed;
                  // Reset bird position when it passes behind camera
                  if (bird.userData.orbitCenterZ > 20) {
                    bird.userData.orbitCenterZ = -80;
                  }
                });

                // Move obstacles and check for collisions
                obstaclesRef.current.forEach(obstacle => {
                  obstacle.position.z += moveSpeed;

                  // Check for collision with car (when obstacle is at car's Z position)
                  if (!obstacle.userData.collisionHandled && obstacle.position.z > 0.5 && obstacle.position.z < 3.5) {
                    obstacle.userData.collisionHandled = true;

                    // Check if car and obstacle are on the same side
                    const carX = carRef.current ? carRef.current.position.x : 0;
                    const obstacleX = obstacle.position.x;
                    const distance = Math.abs(carX - obstacleX);

                    console.log('Collision check: carX=', carX, 'obstacleX=', obstacleX, 'distance=', distance, 'obstacle Z=', obstacle.position.z);

                    if (distance < 1.5) {
                      // HIT! Knock over the cone with dramatic animation
                      console.log('HIT DETECTED!');
                      const startRotationX = obstacle.rotation.x;
                      const startRotationZ = obstacle.rotation.z;
                      const startY = obstacle.position.y;
                      const startX = obstacle.position.x;
                      const startTime = Date.now();
                      const knockDuration = 600;

                      // Determine which direction to knock the cone
                      const knockDirection = carX < obstacleX ? 1 : -1;

                      // Change cone color to bright red when hit
                      obstacle.material.color.setHex(0xFF0000);

                      const animateKnock = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / knockDuration, 1);
                        const easeOut = 1 - Math.pow(1 - progress, 3); // Ease out cubic

                        // Tumble and spin
                        obstacle.rotation.x = startRotationX + (Math.PI * 2) * easeOut;
                        obstacle.rotation.z = startRotationZ + (Math.PI * 1.5) * easeOut;

                        // Fly to the side and up, then down
                        obstacle.position.x = startX + knockDirection * 3 * easeOut;
                        const bounceHeight = Math.sin(progress * Math.PI) * 1.5;
                        obstacle.position.y = startY + bounceHeight;

                        if (progress < 1) {
                          requestAnimationFrame(animateKnock);
                        }
                      };
                      animateKnock();

                      // Camera shake
                      const cameraStartPos = { x: cameraRef.current.position.x, y: cameraRef.current.position.y };
                      const shakeStartTime = Date.now();
                      const shakeDuration = 300;

                      const shakeCamera = () => {
                        const elapsed = Date.now() - shakeStartTime;
                        const progress = Math.min(elapsed / shakeDuration, 1);
                        const intensity = (1 - progress) * 0.15;

                        cameraRef.current.position.x = cameraStartPos.x + (Math.random() - 0.5) * intensity;
                        cameraRef.current.position.y = cameraStartPos.y + (Math.random() - 0.5) * intensity;

                        if (progress < 1) {
                          requestAnimationFrame(shakeCamera);
                        } else {
                          cameraRef.current.position.x = cameraStartPos.x;
                          cameraRef.current.position.y = cameraStartPos.y;
                        }
                      };
                      shakeCamera();

                      // Car bounce and flash
                      if (carRef.current) {
                        // Flash all body parts to yellow
                        const bodyParts = [];
                        const originalColors = [];

                        carRef.current.children.forEach((child, index) => {
                          if (child.material && child.material.color) {
                            bodyParts.push(child);
                            originalColors.push(child.material.color.clone());
                            // Flash bright yellow (except wheels and dark parts)
                            if (child.material.color.getHex() !== 0x1a1a1a &&
                                child.material.color.getHex() !== 0x333333) {
                              child.material.color.setHex(0xFFFF00);
                            }
                          }
                        });

                        const carStartY = carRef.current.position.y;
                        const bounceStartTime = Date.now();
                        const bounceDuration = 200;

                        const bounceCar = () => {
                          const elapsed = Date.now() - bounceStartTime;
                          const progress = Math.min(elapsed / bounceDuration, 1);
                          const bounceAmount = Math.sin(progress * Math.PI * 2) * 0.2;
                          carRef.current.position.y = carStartY + bounceAmount;

                          if (progress < 1) {
                            requestAnimationFrame(bounceCar);
                          } else {
                            carRef.current.position.y = carStartY;
                          }
                        };
                        bounceCar();

                        setTimeout(() => {
                          bodyParts.forEach((part, index) => {
                            part.material.color.copy(originalColors[index]);
                          });
                        }, 200);
                      }
                    } else {
                      // AVOIDED! Make cone flash green
                      console.log('AVOIDED!');
                      obstacle.material.color.setHex(0x00FF00);
                      setTimeout(() => {
                        obstacle.material.color.setHex(0xFF6600);
                      }, 300);
                    }
                  }
                });

                // Check if current obstacle has passed the car
                if (currentObstacleRef.current && currentObstacleRef.current.position.z > 3) {
                  // Obstacle has passed, time for next question
                  currentObstacleRef.current = null;

                  // Move car back to center
                  if (carRef.current) {
                    const startX = carRef.current.position.x;
                    const animationDuration = 500;
                    const startTime = Date.now();

                    const animateCar = () => {
                      const elapsed = Date.now() - startTime;
                      const progress = Math.min(elapsed / animationDuration, 1);
                      if (carRef.current) {
                        carRef.current.position.x = startX + (0 - startX) * progress;
                      }

                      if (progress < 1) {
                        requestAnimationFrame(animateCar);
                      } else {
                        // Car is back in center, show next question
                        const newQuestion = createNewQuestion();
                        setCurrentQuestion(newQuestion);
                        speakSyllable(newQuestion.correctSyllable);
                        setHasAnswered(false);
                        setSelectedSide(null);
                      }
                    };
                    animateCar();
                  }
                }

                // Remove obstacles that are behind camera
                obstaclesRef.current = obstaclesRef.current.filter(obstacle => {
                  if (obstacle.position.z > 5) {
                    scene.remove(obstacle);
                    return false;
                  }
                  return true;
                });
              }

              renderer.render(scene, camera);
            };
            animate();

            // Handle window resize
            const handleResize = () => {
              camera.aspect = window.innerWidth / window.innerHeight;
              camera.updateProjectionMatrix();
              renderer.setSize(window.innerWidth, window.innerHeight);
            };
            window.addEventListener('resize', handleResize);

            // Cleanup
            return () => {
              window.removeEventListener('resize', handleResize);
              if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current);
              }
              if (mountRef.current && renderer.domElement) {
                mountRef.current.removeChild(renderer.domElement);
              }
              renderer.dispose();
            };
          }, []);

          // Hide instructions after 5 seconds
          useEffect(() => {
            const timer = setTimeout(() => {
              setShowInstructions(false);
            }, 5000);

            return () => clearTimeout(timer);
          }, []);

          // Create obstacles on road
          const createObstacle = (side) => {
            if (!sceneRef.current) return;

            const coneGeometry = new THREE.ConeGeometry(0.4, 1.2, 8);
            const coneMaterial = new THREE.MeshStandardMaterial({ color: 0xFF6600 });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);

            const xPosition = side === 'left' ? -2 : 2;
            cone.position.set(xPosition, 0.6, -15);
            cone.castShadow = true;
            cone.userData.collisionHandled = false; // Initialize collision flag
            cone.userData.side = side; // Track which side

            sceneRef.current.add(cone);
            obstaclesRef.current.push(cone);
            currentObstacleRef.current = cone; // Track this obstacle

            console.log('Created obstacle on', side, 'at x:', xPosition);
          };

          // Handle answer
          const handleAnswer = (side) => {
            if (hasAnswered || !currentQuestion) return;

            setHasAnswered(true);
            const isCorrect = side === currentQuestion.correctSide;

            setTotalQuestions(prev => prev + 1);
            setSelectedSide(side);

            // Move car to the chosen lane
            if (carRef.current) {
              const targetX = side === 'left' ? -2 : 2;
              // Smooth animation to the target position
              const startX = carRef.current.position.x;
              const animationDuration = 500; // milliseconds
              const startTime = Date.now();

              const animateCar = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / animationDuration, 1);
                if (carRef.current) {
                  carRef.current.position.x = startX + (targetX - startX) * progress;
                }

                if (progress < 1) {
                  requestAnimationFrame(animateCar);
                }
              };
              animateCar();
            }

            if (isCorrect) {
              setCorrectAnswers(prev => prev + 1);
              setScore(prev => prev + 10);
              // Place obstacle on the OPPOSITE side so car avoids it
              const obstacleSide = side === 'left' ? 'right' : 'left';
              createObstacle(obstacleSide);
            } else {
              setSpeed(prev => Math.max(0, prev - 10));
              // Place obstacle on the SAME side so car hits it
              createObstacle(side);

              if (speed - 10 <= 0) {
                setGameState('gameover');
                return;
              }
            }

            // The next question will be shown automatically after the obstacle passes
            // (handled in the animation loop)
          };

          // Handle keyboard controls
          useEffect(() => {
            const handleKeyDown = (e) => {
              if (gameState !== 'playing') return;

              if (e.key === 'ArrowLeft' && !hasAnswered) {
                handleAnswer('left');
              } else if (e.key === 'ArrowRight' && !hasAnswered) {
                handleAnswer('right');
              } else if (e.key === 'ArrowUp' && currentQuestion) {
                // Repeat syllable pronunciation
                speakSyllable(currentQuestion.correctSyllable);
              } else if (e.key === 'Escape') {
                onBack();
              }
            };

            window.addEventListener('keydown', handleKeyDown);
            return () => window.removeEventListener('keydown', handleKeyDown);
          }, [gameState, hasAnswered, currentQuestion]);

          // Format syllable with case and coloring
          const formatSyllable = (syllable) => {
            if (!syllable) return '';
            const chars = syllable.split('');
            const formatted = chars.map(char => isUpperCase ? char.toUpperCase() : char);

            return (
              <>
                <span className={syllableOrder === 'cv' ? 'text-blue-400' : 'text-red-400'}>
                  {formatted[0]}
                </span>
                <span className={syllableOrder === 'cv' ? 'text-red-400' : 'text-blue-400'}>
                  {formatted[1]}
                </span>
              </>
            );
          };

          return (
            <div className="relative w-full h-screen overflow-hidden">
              <div ref={mountRef} className="w-full h-full" />

              {/* Game Over Overlay */}
              {gameState === 'gameover' && (
                <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                  <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full mx-4">
                    <h1 className="text-6xl font-bold text-center mb-8 text-red-600">
                      GAME OVER!
                    </h1>
                    <div className="space-y-4 mb-8">
                      <div className="bg-gradient-to-r from-blue-100 to-purple-100 rounded-2xl p-6">
                        <p className="text-3xl font-bold text-gray-800">
                          Очки: <span className="text-blue-600">{score}</span>
                        </p>
                      </div>
                      <div className="bg-gradient-to-r from-green-100 to-blue-100 rounded-2xl p-6">
                        <p className="text-3xl font-bold text-gray-800">
                          Правильных ответов: <span className="text-green-600">{correctAnswers}</span> из {totalQuestions}
                        </p>
                      </div>
                      <div className="bg-gradient-to-r from-yellow-100 to-orange-100 rounded-2xl p-6">
                        <p className="text-3xl font-bold text-gray-800">
                          Точность: <span className="text-orange-600">
                            {totalQuestions > 0 ? Math.round((correctAnswers / totalQuestions) * 100) : 0}%
                          </span>
                        </p>
                      </div>
                    </div>
                    <button
                      onClick={onBack}
                      className="w-full bg-gradient-to-r from-purple-500 to-blue-600 text-white rounded-2xl p-6 text-3xl font-bold hover:shadow-xl transition-all transform hover:scale-105"
                    >
                      Вернуться в меню
                    </button>
                  </div>
                </div>
              )}

              {/* HUD Overlay */}
              <div className="absolute top-4 left-4 right-4 flex justify-between items-start pointer-events-none">
                <div className="space-y-2">
                  <div className="bg-black bg-opacity-70 text-white rounded-xl px-6 py-3">
                    <p className="text-2xl font-bold">Скорость: {speed}</p>
                  </div>
                  <div className="bg-black bg-opacity-70 text-white rounded-xl px-6 py-3">
                    <p className="text-2xl font-bold">Очки: {score}</p>
                  </div>
                  <div className="bg-black bg-opacity-70 text-white rounded-xl px-6 py-3">
                    <p className="text-xl font-bold">Правильных: {correctAnswers}/{totalQuestions}</p>
                  </div>
                </div>
                <div className="pointer-events-auto">
                  <button
                    onClick={onBack}
                    className="bg-red-500 hover:bg-red-600 text-white rounded-xl px-6 py-3 text-xl font-bold transition"
                  >
                    ☰ Меню
                  </button>
                </div>
              </div>

              {/* Syllable choices */}
              {currentQuestion && (
                <div className="absolute bottom-0 left-0 right-0 flex pointer-events-none">
                  <div
                    onClick={() => !hasAnswered && handleAnswer('left')}
                    className={`flex-1 font-bold text-8xl py-20 transition-all pointer-events-auto flex items-center justify-center gap-4 ${
                      hasAnswered ? (selectedSide === 'left' ? 'opacity-100' : 'opacity-0') : 'cursor-pointer hover:bg-white hover:bg-opacity-10'
                    }`}
                  >
                    <span className="text-8xl font-bold text-white">←</span>
                    {formatSyllable(currentQuestion.leftSyllable)}
                  </div>
                  <div
                    onClick={() => !hasAnswered && handleAnswer('right')}
                    className={`flex-1 font-bold text-8xl py-20 transition-all pointer-events-auto flex items-center justify-center gap-4 ${
                      hasAnswered ? (selectedSide === 'right' ? 'opacity-100' : 'opacity-0') : 'cursor-pointer hover:bg-white hover:bg-opacity-10'
                    }`}
                  >
                    {formatSyllable(currentQuestion.rightSyllable)}
                    <span className="text-8xl font-bold text-white">→</span>
                  </div>
                </div>
              )}

              {/* Instructions */}
              {showInstructions && (
                <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center pointer-events-none">
                  <div className="bg-black bg-opacity-60 text-white rounded-2xl px-8 py-4">
                    <p className="text-2xl font-bold">
                      ← или → для ответа | ↑ повторить
                    </p>
                  </div>
                </div>
              )}
            </div>
          );
        };

        const RussianSyllablesApp = () => {
          const consonants = ['б', 'в', 'г', 'д', 'ж', 'з', 'к', 'л', 'м', 'н', 'п', 'р', 'с', 'т', 'ф', 'х', 'ц', 'ч', 'ш', 'щ'];
          const vowels = ['а', 'о', 'у', 'ы', 'э', 'я', 'ё', 'ю', 'и', 'е'];
          
          // Список недопустимых слогов по правилам русского языка (на основе таблицы)
          const invalidSyllables = [
            // Ж: не сочетается с Ы, Я, Ю, Э
            'жы', 'жя', 'жю', 'жэ',
            // Ш: не сочетается с Ы, Я, Ё, Ю, Э
            'шы', 'шя', 'шё', 'шю', 'шэ',
            // Ч: не сочетается с Ы, Я, Ю, Э
            'чы', 'чя', 'чю', 'чэ',
            // Щ: не сочетается с Ы, Я, Ю, Э
            'щы', 'щя', 'щю', 'щэ',
            // Ц: не сочетается с Я, Ё, Ю, Э
            'ця', 'цё', 'цю', 'цэ'
          ];

          // Проверка валидности слога
          const isValidSyllable = (consonant, vowel) => {
            return !invalidSyllables.includes(consonant + vowel);
          };
          
          const backgrounds = [
            { name: 'Белый', value: 'bg-white', text: 'text-gray-800' },
            { name: 'Черный', value: 'bg-gray-900', text: 'text-white' },
            { name: 'Серый', value: 'bg-gray-100', text: 'text-gray-800' },
            { name: 'Бежевый', value: 'bg-amber-50', text: 'text-gray-800' },
            { name: 'Синий', value: 'bg-blue-50', text: 'text-gray-800' }
          ];
          
          const [mode, setMode] = useState('random');
          const [selectedConsonant, setSelectedConsonant] = useState('');
          const [currentSyllable, setCurrentSyllable] = useState('');
          const [count, setCount] = useState(0);
          const [animate, setAnimate] = useState(false);
          const [showMenu, setShowMenu] = useState(true);
          const [soundEnabled, setSoundEnabled] = useState(false);
          const [bgIndex, setBgIndex] = useState(0);
          const [isUpperCase, setIsUpperCase] = useState(true);
          const [syllableOrder, setSyllableOrder] = useState('cv'); // 'cv' = consonant-vowel, 'vc' = vowel-consonant

          const generateRandomSyllable = () => {
            let consonant, vowel;
            do {
              consonant = consonants[Math.floor(Math.random() * consonants.length)];
              vowel = vowels[Math.floor(Math.random() * vowels.length)];
            } while (syllableOrder === 'cv' && !isValidSyllable(consonant, vowel));
            return syllableOrder === 'cv' ? consonant + vowel : vowel + consonant;
          };

          const generateSyllableWithConsonant = (consonant) => {
            let vowel;
            if (syllableOrder === 'cv') {
              const validVowels = vowels.filter(v => isValidSyllable(consonant, v));
              vowel = validVowels[Math.floor(Math.random() * validVowels.length)];
              return consonant + vowel;
            } else {
              // For VC mode, no validation needed - all combinations are valid
              vowel = vowels[Math.floor(Math.random() * vowels.length)];
              return vowel + consonant;
            }
          };

          const speakSyllable = (syllable) => {
            if (soundEnabled && 'speechSynthesis' in window) {
              const utterance = new SpeechSynthesisUtterance(syllable);
              utterance.lang = 'ru-RU';
              utterance.rate = 0.7;
              utterance.pitch = 1.2;
              window.speechSynthesis.cancel();
              window.speechSynthesis.speak(utterance);
            }
          };

          const nextSyllable = () => {
            // Сначала озвучиваем ТЕКУЩИЙ слог (если звук включен)
            if (soundEnabled && 'speechSynthesis' in window && currentSyllable) {
              const utterance = new SpeechSynthesisUtterance(currentSyllable);
              utterance.lang = 'ru-RU';
              utterance.rate = 0.7;
              utterance.pitch = 1.2;
              window.speechSynthesis.cancel();
              
              // После окончания произношения показываем новый слог
              utterance.onend = () => {
                showNextSyllable();
              };
              
              window.speechSynthesis.speak(utterance);
            } else {
              // Если звук выключен, сразу показываем новый слог
              showNextSyllable();
            }
          };

          const showNextSyllable = () => {
            setAnimate(true);
            setTimeout(() => {
              let newSyllable;
              // Keep generating until we get a different syllable
              do {
                newSyllable = mode === 'random'
                  ? generateRandomSyllable()
                  : generateSyllableWithConsonant(selectedConsonant);
              } while (newSyllable === currentSyllable);

              setCurrentSyllable(newSyllable);
              setCount(prev => prev + 1);
              setAnimate(false);
            }, 150);
          };

          const startMode = (newMode, consonant = '') => {
            setMode(newMode);
            setSelectedConsonant(consonant);
            setCount(0);
            setShowMenu(false);
            const firstSyllable = newMode === 'random' 
              ? generateRandomSyllable() 
              : generateSyllableWithConsonant(consonant);
            setCurrentSyllable(firstSyllable);
            // Первый слог показывается БЕЗ озвучивания
          };

          useEffect(() => {
            const handleKeyPress = (e) => {
              if (e.code === 'Space' && !showMenu) {
                e.preventDefault();
                nextSyllable();
              }
              if (e.code === 'Escape' && !showMenu) {
                setShowMenu(true);
              }
            };
            window.addEventListener('keydown', handleKeyPress);
            return () => window.removeEventListener('keydown', handleKeyPress);
          }, [showMenu, mode, selectedConsonant, soundEnabled, isUpperCase, currentSyllable, syllableOrder]);

          // Render 3D Game mode
          if (mode === '3d-game' && !showMenu) {
            return (
              <Game3D
                onBack={() => setShowMenu(true)}
                consonants={consonants}
                vowels={vowels}
                isValidSyllable={isValidSyllable}
                syllableOrder={syllableOrder}
                isUpperCase={isUpperCase}
              />
            );
          }

          if (showMenu) {
            return (
              <div className="min-h-screen bg-gradient-to-br from-purple-400 via-pink-400 to-yellow-400 flex items-center justify-center p-4">
                <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-4xl w-full">
                  <h1 className="text-5xl font-bold text-center mb-8 text-purple-600">
                    Учим слоги! 📚
                  </h1>

                  <div className="mb-6 flex justify-center gap-4">
                    <button
                      onClick={() => setSyllableOrder('cv')}
                      className={`px-8 py-4 rounded-xl text-2xl font-bold transition-all transform hover:scale-105 ${
                        syllableOrder === 'cv'
                          ? 'bg-gradient-to-r from-blue-500 to-purple-600 text-white shadow-lg'
                          : 'bg-gray-200 text-gray-600 hover:bg-gray-300'
                      }`}
                    >
                      Согласная + Гласная<br/>
                      <span className="text-3xl">БА</span>
                    </button>
                    <button
                      onClick={() => setSyllableOrder('vc')}
                      className={`px-8 py-4 rounded-xl text-2xl font-bold transition-all transform hover:scale-105 ${
                        syllableOrder === 'vc'
                          ? 'bg-gradient-to-r from-blue-500 to-purple-600 text-white shadow-lg'
                          : 'bg-gray-200 text-gray-600 hover:bg-gray-300'
                      }`}
                    >
                      Гласная + Согласная<br/>
                      <span className="text-3xl">АБ</span>
                    </button>
                  </div>

                  <div className="mb-8 space-y-4">
                    <button
                      onClick={() => startMode('random')}
                      className="w-full bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-2xl p-8 text-3xl font-bold hover:shadow-xl transition-all transform hover:scale-105 flex items-center justify-center gap-4"
                    >
                      <Shuffle />
                      Случайные слоги
                    </button>
                    <button
                      onClick={() => startMode('3d-game')}
                      className="w-full bg-gradient-to-r from-orange-500 to-red-600 text-white rounded-2xl p-8 text-3xl font-bold hover:shadow-xl transition-all transform hover:scale-105 flex items-center justify-center gap-4"
                    >
                      🏎️ 3D Игра
                    </button>
                  </div>

                  <div className="mb-4">
                    <h2 className="text-2xl font-bold text-gray-700 mb-4 flex items-center gap-2">
                      <Filter />
                      Выбери букву:
                    </h2>
                    <div className="grid grid-cols-5 gap-3">
                      {consonants.map(consonant => (
                        <button
                          key={consonant}
                          onClick={() => startMode('selected', consonant)}
                          className="bg-gradient-to-br from-green-400 to-blue-500 text-white rounded-xl p-1 text-3xl font-bold hover:shadow-lg transition-all transform hover:scale-110 flex flex-col items-center justify-center gap-1"
                        >
                          <span>{consonant.toUpperCase()}</span>
                          <span className="text-2xl">{consonant}</span>
                        </button>
                      ))}
                    </div>
                  </div>

                  <div className="mt-6 text-center text-gray-600 text-lg">
                    💡 Нажимай <kbd className="px-3 py-1 bg-gray-200 rounded">Пробел</kbd> для следующего слога
                  </div>
                </div>
              </div>
            );
          }

          return (
            <div
              className={`min-h-screen ${backgrounds[bgIndex].value} flex flex-col items-center justify-center cursor-pointer transition-colors duration-300 overflow-hidden`}
              onClick={nextSyllable}
            >
              <div
                className="absolute top-2 right-2 md:top-6 md:right-6 flex gap-2 md:gap-4 flex-wrap justify-end"
                onClick={(e) => e.stopPropagation()}
              >
                <div className={`bg-opacity-80 ${backgrounds[bgIndex].value === 'bg-gray-900' ? 'bg-white text-gray-900' : 'bg-gray-900 text-white'} rounded-full px-3 py-2 md:px-6 md:py-3 shadow-lg text-lg md:text-2xl font-bold`}>
                  {count}
                </div>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    setIsUpperCase(!isUpperCase);
                  }}
                  className={`rounded-full px-3 py-2 md:px-6 md:py-3 shadow-lg text-base md:text-xl font-bold transition ${
                    backgrounds[bgIndex].value === 'bg-gray-900' ? 'bg-white text-gray-700 hover:bg-gray-100' : 'bg-gray-900 text-white hover:bg-gray-800'
                  }`}
                  title="Переключить регистр"
                >
                  {isUpperCase ? 'АБ' : 'аб'}
                </button>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    setSoundEnabled(!soundEnabled);
                  }}
                  className={`rounded-full px-3 py-2 md:px-6 md:py-3 shadow-lg text-base md:text-xl font-bold transition ${
                    soundEnabled 
                      ? 'bg-green-500 text-white' 
                      : backgrounds[bgIndex].value === 'bg-gray-900' ? 'bg-white text-gray-700' : 'bg-gray-900 text-white'
                  }`}
                  title={soundEnabled ? 'Выключить звук' : 'Включить звук'}
                >
                  {soundEnabled ? '🔊' : '🔇'}
                </button>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    setBgIndex((bgIndex + 1) % backgrounds.length);
                  }}
                  className={`rounded-full px-3 py-2 md:px-6 md:py-3 shadow-lg text-base md:text-xl font-bold transition ${
                    backgrounds[bgIndex].value === 'bg-gray-900' ? 'bg-white text-gray-700 hover:bg-gray-100' : 'bg-gray-900 text-white hover:bg-gray-800'
                  }`}
                  title="Сменить фон"
                >
                  🎨
                </button>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    setShowMenu(true);
                  }}
                  className={`rounded-full px-3 py-2 md:px-6 md:py-3 shadow-lg text-base md:text-xl font-bold transition ${
                    backgrounds[bgIndex].value === 'bg-gray-900' ? 'bg-white text-gray-700 hover:bg-gray-100' : 'bg-gray-900 text-white hover:bg-gray-800'
                  }`}
                  title="Меню"
                >
                  ☰
                </button>
              </div>

              {mode === 'selected' && (
                <div
                  className={`absolute top-2 left-2 md:top-6 md:left-6 rounded-full px-3 py-2 md:px-6 md:py-3 shadow-lg ${
                    backgrounds[bgIndex].value === 'bg-gray-900' ? 'bg-white' : 'bg-gray-900'
                  }`}
                  onClick={(e) => e.stopPropagation()}
                >
                  <span className={`text-lg md:text-2xl font-bold ${
                    backgrounds[bgIndex].value === 'bg-gray-900' ? 'text-gray-900' : 'text-white'
                  }`}>
                    {selectedConsonant.toUpperCase()} {selectedConsonant}
                  </span>
                </div>
              )}

              <div
                className={`transition-all duration-150 ${animate ? 'scale-75 opacity-0' : 'scale-100 opacity-100'} w-full flex justify-center pointer-events-none`}
              >
                <div
                  className={`font-bold ${backgrounds[bgIndex].text} select-none leading-none`}
                  style={{ fontSize: '45vw' }}
                >
                  {syllableOrder === 'cv' ? (
                    <>
                      <span className={backgrounds[bgIndex].value === 'bg-gray-900' ? 'text-blue-400' : 'text-blue-600'}>
                        {isUpperCase ? currentSyllable[0].toUpperCase() : currentSyllable[0]}
                      </span>
                      <span className={backgrounds[bgIndex].value === 'bg-gray-900' ? 'text-red-400' : 'text-red-600'}>
                        {isUpperCase ? currentSyllable[1].toUpperCase() : currentSyllable[1]}
                      </span>
                    </>
                  ) : (
                    <>
                      <span className={backgrounds[bgIndex].value === 'bg-gray-900' ? 'text-red-400' : 'text-red-600'}>
                        {isUpperCase ? currentSyllable[0].toUpperCase() : currentSyllable[0]}
                      </span>
                      <span className={backgrounds[bgIndex].value === 'bg-gray-900' ? 'text-blue-400' : 'text-blue-600'}>
                        {isUpperCase ? currentSyllable[1].toUpperCase() : currentSyllable[1]}
                      </span>
                    </>
                  )}
                </div>
              </div>

              <div
                className={`absolute bottom-4 md:bottom-8 text-sm md:text-xl font-semibold rounded-full px-4 py-2 md:px-8 md:py-4 ${
                  backgrounds[bgIndex].value === 'bg-gray-900' ? 'bg-white text-gray-900' : 'bg-gray-900 text-white'
                } bg-opacity-80`}
                onClick={(e) => e.stopPropagation()}
              >
                Нажми ПРОБЕЛ или экран для следующего слога
              </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<RussianSyllablesApp />);
    </script>
</body>
</html>
